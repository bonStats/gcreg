#' The COLS algorithm.
#' 
#' @param par initial starting point of algorithm.
#' @param Y (scaled) observation matrix.
#' @param X orthonormalised design matrix.
#' @param oracle_fun function that determines if a given point is inside the constrained space.
#' @param control list of controls generated by cols_control().
#' @param ... additional parameters passed to control if not specified.
#' @return contrained minimum solution.
#' @examples
#' #TO DO

# basic implementation
optim_COLS <- function(par, Y, X, oracle_fun, control = cols_control(...), ...) {
  # all in orthonormal basis
  # oracle function should have converter within
  # orcale function is set up by a helper function which tries different points? Or needs to be specified.
  
  p <- ncol(X)
  
  # aim: OLS beta orthonormal design matrix
  aim_gamma <- crossprod(X, Y)
  curr_gamma <- matrix(par, ncol = 1)
  
  # line search function in 1 dimension
  ls_find <- gen_line_search(oracle_fun)
  
  # convergence counter
  conv_counter <- 0
  
  # while loop index
  i <- 0
  
  # step size intiate
  step_size <- control$step_start
  
  # decide which method to use and set function
  if(control$method == "best-step"){
    
    find_gamma <- function(cur, index) { # index not used
      
      pot_new_gammas <- lapply(1:p, FUN = ls_find, cur = cur, aim = aim_gamma)
      
      pot_moves <- diag(sapply(pot_new_gammas, function(g) {g - cur}))
      
      ix <- which.min(2 * as.vector(cur - aim_gamma) * pot_moves + pot_moves^2)
      
      list(gamma = pot_new_gammas[[ix]], pot_moves = pot_moves)
    
    }
      
  } else {
    # default is method = "simple"
    find_gamma <- function(cur, index) {
      
      list(gamma = ls_find(index = index, cur = cur, aim = aim_gamma), pot_moves = NULL)
      
    }
    
  }
  
  gamms <- list()
  
  # search
  while(i <= control$maxit & conv_counter < 2 * p){

    ix <- (i %% p) + 1
    
    # finds the full move possible based on the function defined by find_gamma above
    full_move <- find_gamma(cur = curr_gamma, index = ix)
    
    # reduces move to specified step size (works for change in one or several coordinates)
    new_gamma <- replace(curr_gamma, ix, curr_gamma[ix] * (1 - step_size) + full_move$gamma[ix] * step_size)
    gamms[[i+1]] <- new_gamma
    if(all(abs(new_gamma - curr_gamma) < control$tol)) {
      conv_counter <- conv_counter + 1
    } else {
      conv_counter <- 0
    }
    
    # update gamma
    curr_gamma <- new_gamma
    
    # increment
    i <- i + 1
    
    # change step size
    if((i %% (2 * p)) == 0){
      step_size <- min(step_size + control$step_increment, 1)
    }
    
  }
  
  attr(new_gamma,"iter") <- i
  
  pot_new_gammas <- lapply(1:p, FUN = ls_find, cur = new_gamma, aim = aim_gamma)
  
  attr(new_gamma,"pot_moves") <- diag(sapply(pot_new_gammas, function(g) {g - new_gamma}))
  
  return(new_gamma)

}
